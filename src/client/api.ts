/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * BPL Backend API
 * This is the backend API for the BPL project.
 *
 * OpenAPI spec version: 2.0
 * Contact: Liberatorist@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration?: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum AggregationType {
    SUM_LATEST = 'SUM_LATEST',
    EARLIEST = 'EARLIEST',
    EARLIEST_FRESH_ITEM = 'EARLIEST_FRESH_ITEM',
    MAXIMUM = 'MAXIMUM',
    MINIMUM = 'MINIMUM'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ApplicationStatus {
    applied = 'applied',
    accepted = 'accepted',
    waitlisted = 'waitlisted',
    none = 'none'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ApprovalStatus {
    APPROVED = 'APPROVED',
    REJECTED = 'REJECTED',
    PENDING = 'PENDING'
}

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * 
     * @type {Array<Objective>}
     * @memberof Category
     */
    objectives: Array<Objective>;
    /**
     * 
     * @type {ScoringPreset}
     * @memberof Category
     */
    scoring_preset?: ScoringPreset;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    scoring_preset_id?: number;
    /**
     * 
     * @type {Array<Category>}
     * @memberof Category
     */
    sub_categories: Array<Category>;
}

/**
 * 
 * @export
 * @interface CategoryCreate
 */
export interface CategoryCreate {
    /**
     * 
     * @type {number}
     * @memberof CategoryCreate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryCreate
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof CategoryCreate
     */
    parent_id: number;
    /**
     * 
     * @type {number}
     * @memberof CategoryCreate
     */
    scoring_preset_id?: number;
}

/**
 * 
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * 
     * @type {ItemField}
     * @memberof Condition
     */
    field: ItemField;
    /**
     * 
     * @type {number}
     * @memberof Condition
     */
    id: number;
    /**
     * 
     * @type {Operator}
     * @memberof Condition
     */
    operator: Operator;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    value: string;
}

/**
 * 
 * @export
 * @interface ConditionCreate
 */
export interface ConditionCreate {
    /**
     * 
     * @type {ConditionCreateField}
     * @memberof ConditionCreate
     */
    field: ConditionCreateField;
    /**
     * 
     * @type {number}
     * @memberof ConditionCreate
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ConditionCreate
     */
    objective_id: number;
    /**
     * 
     * @type {ConditionCreateField}
     * @memberof ConditionCreate
     */
    operator: ConditionCreateField;
    /**
     * 
     * @type {string}
     * @memberof ConditionCreate
     */
    value: string;
}

/**
 * 
 * @export
 * @interface ConditionCreateField
 */
export interface ConditionCreateField {
}

/**
 * 
 * @export
 * @interface ConditionMappings
 */
export interface ConditionMappings {
    /**
     * 
     * @type {{ [key: string]: FieldType; }}
     * @memberof ConditionMappings
     */
    field_to_type: { [key: string]: FieldType; };
    /**
     * 
     * @type {{ [key: string]: Array<NumberField>; }}
     * @memberof ConditionMappings
     */
    objective_type_to_number_fields: { [key: string]: Array<NumberField>; };
    /**
     * 
     * @type {{ [key: string]: Array<Operator>; }}
     * @memberof ConditionMappings
     */
    valid_operators: { [key: string]: Array<Operator>; };
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Difftype {
    Added = 'Added',
    Removed = 'Removed',
    Changed = 'Changed',
    Unchanged = 'Unchanged'
}

/**
 * 
 * @export
 * @interface DiscordBotLoginBody
 */
export interface DiscordBotLoginBody {
    /**
     * 
     * @type {string}
     * @memberof DiscordBotLoginBody
     */
    token: string;
}

/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    application_start_time: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    event_end_time: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    event_start_time: string;
    /**
     * 
     * @type {GameVersion}
     * @memberof Event
     */
    game_version: GameVersion;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    id: number;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    is_current: boolean;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    max_size: number;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    scoring_category_id: number;
    /**
     * 
     * @type {Array<Team>}
     * @memberof Event
     */
    teams: Array<Team>;
}

/**
 * 
 * @export
 * @interface EventCreate
 */
export interface EventCreate {
    /**
     * 
     * @type {string}
     * @memberof EventCreate
     */
    application_start_time: string;
    /**
     * 
     * @type {string}
     * @memberof EventCreate
     */
    event_end_time: string;
    /**
     * 
     * @type {string}
     * @memberof EventCreate
     */
    event_start_time: string;
    /**
     * 
     * @type {GameVersion}
     * @memberof EventCreate
     */
    game_version: GameVersion;
    /**
     * 
     * @type {number}
     * @memberof EventCreate
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EventCreate
     */
    is_current?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EventCreate
     */
    max_size: number;
    /**
     * 
     * @type {string}
     * @memberof EventCreate
     */
    name: string;
}

/**
 * 
 * @export
 * @interface EventStatus
 */
export interface EventStatus {
    /**
     * 
     * @type {ApplicationStatus}
     * @memberof EventStatus
     */
    application_status: ApplicationStatus;
    /**
     * 
     * @type {number}
     * @memberof EventStatus
     */
    team_id?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ExpectedPlayTime {
    VERY_LOW = 'VERY_LOW',
    LOW = 'LOW',
    MEDIUM = 'MEDIUM',
    HIGH = 'HIGH',
    VERY_HIGH = 'VERY_HIGH',
    EXTREME = 'EXTREME',
    NO_LIFE = 'NO_LIFE'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum FieldType {
    string = 'string',
    int = 'int',
    bool = 'bool',
    string_2 = 'string[]'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum GameVersion {
    poe1 = 'poe1',
    poe2 = 'poe2'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ItemField {
    BASE_TYPE = 'BASE_TYPE',
    NAME = 'NAME',
    TYPE_LINE = 'TYPE_LINE',
    QUALITY = 'QUALITY',
    LEVEL = 'LEVEL',
    RARITY = 'RARITY',
    ILVL = 'ILVL',
    FRAME_TYPE = 'FRAME_TYPE',
    TALISMAN_TIER = 'TALISMAN_TIER',
    ENCHANT_MODS = 'ENCHANT_MODS',
    EXPLICIT_MODS = 'EXPLICIT_MODS',
    IMPLICIT_MODS = 'IMPLICIT_MODS',
    CRAFTED_MODS = 'CRAFTED_MODS',
    FRACTURED_MODS = 'FRACTURED_MODS',
    MAX_LINKS = 'MAX_LINKS',
    SOCKETS = 'SOCKETS',
    INCUBATOR_KILLS = 'INCUBATOR_KILLS',
    IS_CORRUPTED = 'IS_CORRUPTED',
    IS_VAAL = 'IS_VAAL',
    SANCTUM_AFFLICTIONS = 'SANCTUM_AFFLICTIONS',
    TEMPLE_ROOMS = 'TEMPLE_ROOMS',
    RITUAL_VESSEL_BOSSES = 'RITUAL_VESSEL_BOSSES',
    RITUAL_VESSEL_MAP = 'RITUAL_VESSEL_MAP'
}

/**
 * 
 * @export
 * @interface JobCreate
 */
export interface JobCreate {
    /**
     * 
     * @type {number}
     * @memberof JobCreate
     */
    duration_in_seconds?: number;
    /**
     * 
     * @type {string}
     * @memberof JobCreate
     */
    end_date?: string;
    /**
     * 
     * @type {number}
     * @memberof JobCreate
     */
    event_id?: number;
    /**
     * 
     * @type {JobType}
     * @memberof JobCreate
     */
    job_type?: JobType;
    /**
     * 
     * @type {number}
     * @memberof JobCreate
     */
    sleep_after_each_run_seconds?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum JobType {
    FetchStashChanges = 'FetchStashChanges',
    EvaluateStashChanges = 'EvaluateStashChanges',
    FetchCharacterData = 'FetchCharacterData'
}

/**
 * 
 * @export
 * @interface LadderEntry
 */
export interface LadderEntry {
    /**
     * 
     * @type {string}
     * @memberof LadderEntry
     */
    account_name: string;
    /**
     * 
     * @type {string}
     * @memberof LadderEntry
     */
    character_class: string;
    /**
     * 
     * @type {string}
     * @memberof LadderEntry
     */
    character_name: string;
    /**
     * 
     * @type {number}
     * @memberof LadderEntry
     */
    delve: number;
    /**
     * 
     * @type {number}
     * @memberof LadderEntry
     */
    experience: number;
    /**
     * 
     * @type {number}
     * @memberof LadderEntry
     */
    level: number;
    /**
     * 
     * @type {number}
     * @memberof LadderEntry
     */
    rank: number;
    /**
     * 
     * @type {number}
     * @memberof LadderEntry
     */
    user_id: number;
}

/**
 * 
 * @export
 * @interface MinimalUser
 */
export interface MinimalUser {
    /**
     * 
     * @type {string}
     * @memberof MinimalUser
     */
    display_name: string;
    /**
     * 
     * @type {number}
     * @memberof MinimalUser
     */
    id: number;
}

/**
 * 
 * @export
 * @interface NonSensitiveUser
 */
export interface NonSensitiveUser {
    /**
     * 
     * @type {string}
     * @memberof NonSensitiveUser
     */
    account_name?: string;
    /**
     * 
     * @type {string}
     * @memberof NonSensitiveUser
     */
    discord_id?: string;
    /**
     * 
     * @type {string}
     * @memberof NonSensitiveUser
     */
    discord_name?: string;
    /**
     * 
     * @type {string}
     * @memberof NonSensitiveUser
     */
    display_name: string;
    /**
     * 
     * @type {number}
     * @memberof NonSensitiveUser
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof NonSensitiveUser
     */
    twitch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof NonSensitiveUser
     */
    twitch_name?: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum NumberField {
    STACK_SIZE = 'STACK_SIZE',
    PLAYER_LEVEL = 'PLAYER_LEVEL',
    DELVE_DEPTH = 'DELVE_DEPTH',
    PANTHEON = 'PANTHEON',
    ASCENDANCY = 'ASCENDANCY',
    PLAYER_SCORE = 'PLAYER_SCORE',
    SUBMISSION_VALUE = 'SUBMISSION_VALUE'
}

/**
 * 
 * @export
 * @interface Objective
 */
export interface Objective {
    /**
     * 
     * @type {AggregationType}
     * @memberof Objective
     */
    aggregation: AggregationType;
    /**
     * 
     * @type {number}
     * @memberof Objective
     */
    category_id: number;
    /**
     * 
     * @type {Array<Condition>}
     * @memberof Objective
     */
    conditions: Array<Condition>;
    /**
     * 
     * @type {string}
     * @memberof Objective
     */
    extra: string;
    /**
     * 
     * @type {number}
     * @memberof Objective
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Objective
     */
    name: string;
    /**
     * 
     * @type {NumberField}
     * @memberof Objective
     */
    number_field: NumberField;
    /**
     * 
     * @type {ObjectiveType}
     * @memberof Objective
     */
    objective_type: ObjectiveType;
    /**
     * 
     * @type {number}
     * @memberof Objective
     */
    required_number: number;
    /**
     * 
     * @type {ScoringPreset}
     * @memberof Objective
     */
    scoring_preset?: ScoringPreset;
    /**
     * 
     * @type {number}
     * @memberof Objective
     */
    scoring_preset_id?: number;
    /**
     * 
     * @type {string}
     * @memberof Objective
     */
    valid_from?: string;
    /**
     * 
     * @type {string}
     * @memberof Objective
     */
    valid_to?: string;
}

/**
 * 
 * @export
 * @interface ObjectiveConditionCreate
 */
export interface ObjectiveConditionCreate {
    /**
     * 
     * @type {ConditionCreateField}
     * @memberof ObjectiveConditionCreate
     */
    field: ConditionCreateField;
    /**
     * 
     * @type {number}
     * @memberof ObjectiveConditionCreate
     */
    id?: number;
    /**
     * 
     * @type {ConditionCreateField}
     * @memberof ObjectiveConditionCreate
     */
    operator: ConditionCreateField;
    /**
     * 
     * @type {string}
     * @memberof ObjectiveConditionCreate
     */
    value: string;
}

/**
 * 
 * @export
 * @interface ObjectiveCreate
 */
export interface ObjectiveCreate {
    /**
     * 
     * @type {AggregationType}
     * @memberof ObjectiveCreate
     */
    aggregation: AggregationType;
    /**
     * 
     * @type {number}
     * @memberof ObjectiveCreate
     */
    category_id: number;
    /**
     * 
     * @type {Array<ObjectiveConditionCreate>}
     * @memberof ObjectiveCreate
     */
    conditions: Array<ObjectiveConditionCreate>;
    /**
     * 
     * @type {string}
     * @memberof ObjectiveCreate
     */
    extra?: string;
    /**
     * 
     * @type {number}
     * @memberof ObjectiveCreate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ObjectiveCreate
     */
    name: string;
    /**
     * 
     * @type {NumberField}
     * @memberof ObjectiveCreate
     */
    number_field: NumberField;
    /**
     * 
     * @type {ObjectiveType}
     * @memberof ObjectiveCreate
     */
    objective_type: ObjectiveType;
    /**
     * 
     * @type {number}
     * @memberof ObjectiveCreate
     */
    required_number: number;
    /**
     * 
     * @type {number}
     * @memberof ObjectiveCreate
     */
    scoring_preset_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ObjectiveCreate
     */
    valid_from?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectiveCreate
     */
    valid_to?: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ObjectiveType {
    ITEM = 'ITEM',
    PLAYER = 'PLAYER',
    SUBMISSION = 'SUBMISSION'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Operator {
    EQ = 'EQ',
    NEQ = 'NEQ',
    GT = 'GT',
    LT = 'LT',
    IN = 'IN',
    NOT_IN = 'NOT_IN',
    MATCHES = 'MATCHES',
    CONTAINS = 'CONTAINS',
    CONTAINS_MATCH = 'CONTAINS_MATCH',
    LENGTH_EQ = 'LENGTH_EQ',
    LENGTH_GT = 'LENGTH_GT',
    LENGTH_LT = 'LENGTH_LT'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Permission {
    admin = 'admin',
    command_team = 'command_team'
}

/**
 * 
 * @export
 * @interface RecurringJob
 */
export interface RecurringJob {
    /**
     * 
     * @type {string}
     * @memberof RecurringJob
     */
    end_date: string;
    /**
     * 
     * @type {number}
     * @memberof RecurringJob
     */
    event_id: number;
    /**
     * 
     * @type {JobType}
     * @memberof RecurringJob
     */
    job_type: JobType;
    /**
     * 
     * @type {number}
     * @memberof RecurringJob
     */
    sleep_after_each_run_seconds: number;
}

/**
 * 
 * @export
 * @interface Score
 */
export interface Score {
    /**
     * 
     * @type {boolean}
     * @memberof Score
     */
    finished: boolean;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    number: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    points: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    rank: number;
    /**
     * 
     * @type {string}
     * @memberof Score
     */
    timestamp: string;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    user_id: number;
}

/**
 * 
 * @export
 * @interface ScoreDiff
 */
export interface ScoreDiff {
    /**
     * 
     * @type {Difftype}
     * @memberof ScoreDiff
     */
    diff_type: Difftype;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScoreDiff
     */
    field_diff: Array<string>;
    /**
     * 
     * @type {Score}
     * @memberof ScoreDiff
     */
    score: Score;
}

/**
 * 
 * @export
 * @interface ScoreMap
 */
export interface ScoreMap {
    [key: string]: ScoreDiff;

}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ScoringMethod {
    PRESENCE = 'PRESENCE',
    POINTS_FROM_VALUE = 'POINTS_FROM_VALUE',
    RANKED_TIME = 'RANKED_TIME',
    RANKED_VALUE = 'RANKED_VALUE',
    RANKED_REVERSE = 'RANKED_REVERSE',
    RANKED_COMPLETION_TIME = 'RANKED_COMPLETION_TIME',
    BONUS_PER_COMPLETION = 'BONUS_PER_COMPLETION'
}

/**
 * 
 * @export
 * @interface ScoringPreset
 */
export interface ScoringPreset {
    /**
     * 
     * @type {string}
     * @memberof ScoringPreset
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof ScoringPreset
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ScoringPreset
     */
    name: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ScoringPreset
     */
    points: Array<number>;
    /**
     * 
     * @type {ScoringMethod}
     * @memberof ScoringPreset
     */
    scoring_method: ScoringMethod;
    /**
     * 
     * @type {ScoringPresetType}
     * @memberof ScoringPreset
     */
    type: ScoringPresetType;
}

/**
 * 
 * @export
 * @interface ScoringPresetCreate
 */
export interface ScoringPresetCreate {
    /**
     * 
     * @type {string}
     * @memberof ScoringPresetCreate
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoringPresetCreate
     */
    event_id: number;
    /**
     * 
     * @type {number}
     * @memberof ScoringPresetCreate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ScoringPresetCreate
     */
    name: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ScoringPresetCreate
     */
    points: Array<number>;
    /**
     * 
     * @type {ScoringMethod}
     * @memberof ScoringPresetCreate
     */
    scoring_method: ScoringMethod;
    /**
     * 
     * @type {ScoringPresetType}
     * @memberof ScoringPresetCreate
     */
    type: ScoringPresetType;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ScoringPresetType {
    OBJECTIVE = 'OBJECTIVE',
    CATEGORY = 'CATEGORY'
}

/**
 * 
 * @export
 * @interface Signup
 */
export interface Signup {
    /**
     * 
     * @type {ExpectedPlayTime}
     * @memberof Signup
     */
    expected_playtime: ExpectedPlayTime;
    /**
     * 
     * @type {number}
     * @memberof Signup
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Signup
     */
    team_id?: number;
    /**
     * 
     * @type {string}
     * @memberof Signup
     */
    timestamp: string;
    /**
     * 
     * @type {NonSensitiveUser}
     * @memberof Signup
     */
    user: NonSensitiveUser;
}

/**
 * 
 * @export
 * @interface SignupCreate
 */
export interface SignupCreate {
    /**
     * 
     * @type {ExpectedPlayTime}
     * @memberof SignupCreate
     */
    expected_playtime: ExpectedPlayTime;
}

/**
 * 
 * @export
 * @interface Submission
 */
export interface Submission {
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof Submission
     */
    approval_status: ApprovalStatus;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    comment: string;
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    number: number;
    /**
     * 
     * @type {Objective}
     * @memberof Submission
     */
    objective?: Objective;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    proof: string;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    review_comment?: string;
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    reviewer_id?: number;
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    team_id?: number;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    timestamp: string;
    /**
     * 
     * @type {NonSensitiveUser}
     * @memberof Submission
     */
    user?: NonSensitiveUser;
}

/**
 * 
 * @export
 * @interface SubmissionCreate
 */
export interface SubmissionCreate {
    /**
     * 
     * @type {string}
     * @memberof SubmissionCreate
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof SubmissionCreate
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof SubmissionCreate
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof SubmissionCreate
     */
    objective_id: number;
    /**
     * 
     * @type {string}
     * @memberof SubmissionCreate
     */
    proof?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmissionCreate
     */
    timestamp: string;
}

/**
 * 
 * @export
 * @interface SubmissionReview
 */
export interface SubmissionReview {
    /**
     * 
     * @type {ConditionCreateField}
     * @memberof SubmissionReview
     */
    approval_status: ConditionCreateField;
    /**
     * 
     * @type {string}
     * @memberof SubmissionReview
     */
    review_comment?: string;
}

/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {Array<string>}
     * @memberof Team
     */
    allowed_classes: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    event_id: number;
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    name: string;
}

/**
 * 
 * @export
 * @interface TeamCreate
 */
export interface TeamCreate {
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamCreate
     */
    allowed_classes: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof TeamCreate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamCreate
     */
    name: string;
}

/**
 * 
 * @export
 * @interface TeamUserCreate
 */
export interface TeamUserCreate {
    /**
     * 
     * @type {boolean}
     * @memberof TeamUserCreate
     */
    is_team_lead?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TeamUserCreate
     */
    team_id?: number;
    /**
     * 
     * @type {number}
     * @memberof TeamUserCreate
     */
    user_id: number;
}

/**
 * 
 * @export
 * @interface TwitchStream
 */
export interface TwitchStream {
    /**
     * 
     * @type {number}
     * @memberof TwitchStream
     */
    backend_user_id?: number;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    game_id?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    game_name?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TwitchStream
     */
    is_mature?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    language?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    started_at?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TwitchStream
     */
    tag_ids?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TwitchStream
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    user_id?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    user_login?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    user_name?: string;
    /**
     * 
     * @type {number}
     * @memberof TwitchStream
     */
    viewer_count?: number;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    account_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    discord_id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    discord_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    display_name: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id: number;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof User
     */
    permissions: Array<Permission>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    token_expiry_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    twitch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    twitch_name?: string;
}

/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    display_name: string;
}


/**
 * ConditionApi - fetch parameter creator
 * @export
 */
export const ConditionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a condition
         * @param {ConditionCreate} condition Condition to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCondition(condition: ConditionCreate, options: any = {}): FetchArgs {
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling createCondition.');
            }
            const localVarPath = `/scoring/conditions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConditionCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(condition || {}) : (condition || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a condition
         * @param {number} id Condition Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCondition(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCondition.');
            }
            const localVarPath = `/scoring/conditions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get valid mappings for conditions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidMappings(options: any = {}): FetchArgs {
            const localVarPath = `/scoring/conditions/valid-mappings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConditionApi - functional programming interface
 * @export
 */
export const ConditionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a condition
         * @param {ConditionCreate} condition Condition to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCondition(condition: ConditionCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Condition> {
            const localVarFetchArgs = ConditionApiFetchParamCreator(configuration).createCondition(condition, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a condition
         * @param {number} id Condition Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCondition(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConditionApiFetchParamCreator(configuration).deleteCondition(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get valid mappings for conditions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidMappings(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ConditionMappings> {
            const localVarFetchArgs = ConditionApiFetchParamCreator(configuration).getValidMappings(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConditionApi - factory interface
 * @export
 */
export const ConditionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a condition
         * @param {ConditionCreate} condition Condition to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCondition(condition: ConditionCreate, options?: any) {
            return ConditionApiFp(configuration).createCondition(condition, options)(fetch, basePath);
        },
        /**
         * Deletes a condition
         * @param {number} id Condition Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCondition(id: number, options?: any) {
            return ConditionApiFp(configuration).deleteCondition(id, options)(fetch, basePath);
        },
        /**
         * Get valid mappings for conditions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidMappings(options?: any) {
            return ConditionApiFp(configuration).getValidMappings(options)(fetch, basePath);
        },
    };
};

/**
 * ConditionApi - object-oriented interface
 * @export
 * @class ConditionApi
 * @extends {BaseAPI}
 */
export class ConditionApi extends BaseAPI {
    /**
     * Creates a condition
     * @param {ConditionCreate} condition Condition to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionApi
     */
    public createCondition(condition: ConditionCreate, options?: any) {
        return ConditionApiFp(this.configuration).createCondition(condition, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a condition
     * @param {number} id Condition Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionApi
     */
    public deleteCondition(id: number, options?: any) {
        return ConditionApiFp(this.configuration).deleteCondition(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get valid mappings for conditions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionApi
     */
    public getValidMappings(options?: any) {
        return ConditionApiFp(this.configuration).getValidMappings(options)(this.fetch, this.basePath);
    }

}

/**
 * EventApi - fetch parameter creator
 * @export
 */
export const EventApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates or updates an event
         * @param {EventCreate} event Event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(event: EventCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event' is not null or undefined
            if (event === null || event === undefined) {
                throw new RequiredError('event','Required parameter event was null or undefined when calling createEvent.');
            }
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(event || {}) : (event || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteEvent.');
            }
            const localVarPath = `/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Duplicates an event's configuration
         * @param {number} event_id Event Id
         * @param {EventCreate} event Event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateEvent(event_id: number, event: EventCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling duplicateEvent.');
            }
            // verify required parameter 'event' is not null or undefined
            if (event === null || event === undefined) {
                throw new RequiredError('event','Required parameter event was null or undefined when calling duplicateEvent.');
            }
            const localVarPath = `/events/{event_id}/duplicate`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(event || {}) : (event || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the users application status for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventStatusForUser(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getEventStatusForUser.');
            }
            const localVarPath = `/events/{event_id}/status`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(options: any = {}): FetchArgs {
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates or updates an event
         * @param {EventCreate} event Event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(event: EventCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Event> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).createEvent(event, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).deleteEvent(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Duplicates an event's configuration
         * @param {number} event_id Event Id
         * @param {EventCreate} event Event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateEvent(event_id: number, event: EventCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Event> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).duplicateEvent(event_id, event, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the users application status for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventStatusForUser(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventStatus> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventStatusForUser(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEvents(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates or updates an event
         * @param {EventCreate} event Event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(event: EventCreate, options?: any) {
            return EventApiFp(configuration).createEvent(event, options)(fetch, basePath);
        },
        /**
         * Deletes an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(event_id: number, options?: any) {
            return EventApiFp(configuration).deleteEvent(event_id, options)(fetch, basePath);
        },
        /**
         * Duplicates an event's configuration
         * @param {number} event_id Event Id
         * @param {EventCreate} event Event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateEvent(event_id: number, event: EventCreate, options?: any) {
            return EventApiFp(configuration).duplicateEvent(event_id, event, options)(fetch, basePath);
        },
        /**
         * Gets the users application status for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventStatusForUser(event_id: number, options?: any) {
            return EventApiFp(configuration).getEventStatusForUser(event_id, options)(fetch, basePath);
        },
        /**
         * Fetches all events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(options?: any) {
            return EventApiFp(configuration).getEvents(options)(fetch, basePath);
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * Creates or updates an event
     * @param {EventCreate} event Event to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public createEvent(event: EventCreate, options?: any) {
        return EventApiFp(this.configuration).createEvent(event, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public deleteEvent(event_id: number, options?: any) {
        return EventApiFp(this.configuration).deleteEvent(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Duplicates an event's configuration
     * @param {number} event_id Event Id
     * @param {EventCreate} event Event to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public duplicateEvent(event_id: number, event: EventCreate, options?: any) {
        return EventApiFp(this.configuration).duplicateEvent(event_id, event, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the users application status for an event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventStatusForUser(event_id: number, options?: any) {
        return EventApiFp(this.configuration).getEventStatusForUser(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEvents(options?: any) {
        return EventApiFp(this.configuration).getEvents(options)(this.fetch, this.basePath);
    }

}

/**
 * JobsApi - fetch parameter creator
 * @export
 */
export const JobsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all recurring jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(options: any = {}): FetchArgs {
            const localVarPath = `/jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a recurring job
         * @param {JobCreate} job Job to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startJob(job: JobCreate, options: any = {}): FetchArgs {
            // verify required parameter 'job' is not null or undefined
            if (job === null || job === undefined) {
                throw new RequiredError('job','Required parameter job was null or undefined when calling startJob.');
            }
            const localVarPath = `/jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JobCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(job || {}) : (job || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all recurring jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RecurringJob>> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).getJobs(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Start a recurring job
         * @param {JobCreate} job Job to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startJob(job: JobCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecurringJob> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).startJob(job, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all recurring jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(options?: any) {
            return JobsApiFp(configuration).getJobs(options)(fetch, basePath);
        },
        /**
         * Start a recurring job
         * @param {JobCreate} job Job to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startJob(job: JobCreate, options?: any) {
            return JobsApiFp(configuration).startJob(job, options)(fetch, basePath);
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * Get all recurring jobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobs(options?: any) {
        return JobsApiFp(this.configuration).getJobs(options)(this.fetch, this.basePath);
    }

    /**
     * Start a recurring job
     * @param {JobCreate} job Job to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public startJob(job: JobCreate, options?: any) {
        return JobsApiFp(this.configuration).startJob(job, options)(this.fetch, this.basePath);
    }

}

/**
 * LadderApi - fetch parameter creator
 * @export
 */
export const LadderApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the ladder for an event
         * @param {number} event_id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLadder(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getLadder.');
            }
            const localVarPath = `/events/{event_id}/ladder`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LadderApi - functional programming interface
 * @export
 */
export const LadderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the ladder for an event
         * @param {number} event_id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLadder(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LadderEntry>> {
            const localVarFetchArgs = LadderApiFetchParamCreator(configuration).getLadder(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LadderApi - factory interface
 * @export
 */
export const LadderApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get the ladder for an event
         * @param {number} event_id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLadder(event_id: number, options?: any) {
            return LadderApiFp(configuration).getLadder(event_id, options)(fetch, basePath);
        },
    };
};

/**
 * LadderApi - object-oriented interface
 * @export
 * @class LadderApi
 * @extends {BaseAPI}
 */
export class LadderApi extends BaseAPI {
    /**
     * Get the ladder for an event
     * @param {number} event_id Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LadderApi
     */
    public getLadder(event_id: number, options?: any) {
        return LadderApiFp(this.configuration).getLadder(event_id, options)(this.fetch, this.basePath);
    }

}

/**
 * OauthApi - fetch parameter creator
 * @export
 */
export const OauthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Logs in the discord bot (only for internal use)
         * @param {DiscordBotLoginBody} body Discord bot login body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginDiscordBot(body: DiscordBotLoginBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loginDiscordBot.');
            }
            const localVarPath = `/oauth2/discord/bot-login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DiscordBotLoginBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to discord oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2DiscordGet(options: any = {}): FetchArgs {
            const localVarPath = `/oauth2/discord`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirect handler for discord oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2DiscordRedirectGet(options: any = {}): FetchArgs {
            const localVarPath = `/oauth2/discord/redirect`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to twitch oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2TwitchGet(options: any = {}): FetchArgs {
            const localVarPath = `/oauth2/twitch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirect handler for twitch oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2TwitchRedirectGet(options: any = {}): FetchArgs {
            const localVarPath = `/oauth2/twitch/redirect`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OauthApi - functional programming interface
 * @export
 */
export const OauthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Logs in the discord bot (only for internal use)
         * @param {DiscordBotLoginBody} body Discord bot login body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginDiscordBot(body: DiscordBotLoginBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = OauthApiFetchParamCreator(configuration).loginDiscordBot(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Redirects to discord oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2DiscordGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OauthApiFetchParamCreator(configuration).oauth2DiscordGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Redirect handler for discord oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2DiscordRedirectGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OauthApiFetchParamCreator(configuration).oauth2DiscordRedirectGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Redirects to twitch oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2TwitchGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OauthApiFetchParamCreator(configuration).oauth2TwitchGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Redirect handler for twitch oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2TwitchRedirectGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OauthApiFetchParamCreator(configuration).oauth2TwitchRedirectGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OauthApi - factory interface
 * @export
 */
export const OauthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Logs in the discord bot (only for internal use)
         * @param {DiscordBotLoginBody} body Discord bot login body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginDiscordBot(body: DiscordBotLoginBody, options?: any) {
            return OauthApiFp(configuration).loginDiscordBot(body, options)(fetch, basePath);
        },
        /**
         * Redirects to discord oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2DiscordGet(options?: any) {
            return OauthApiFp(configuration).oauth2DiscordGet(options)(fetch, basePath);
        },
        /**
         * Redirect handler for discord oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2DiscordRedirectGet(options?: any) {
            return OauthApiFp(configuration).oauth2DiscordRedirectGet(options)(fetch, basePath);
        },
        /**
         * Redirects to twitch oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2TwitchGet(options?: any) {
            return OauthApiFp(configuration).oauth2TwitchGet(options)(fetch, basePath);
        },
        /**
         * Redirect handler for twitch oauth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2TwitchRedirectGet(options?: any) {
            return OauthApiFp(configuration).oauth2TwitchRedirectGet(options)(fetch, basePath);
        },
    };
};

/**
 * OauthApi - object-oriented interface
 * @export
 * @class OauthApi
 * @extends {BaseAPI}
 */
export class OauthApi extends BaseAPI {
    /**
     * Logs in the discord bot (only for internal use)
     * @param {DiscordBotLoginBody} body Discord bot login body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public loginDiscordBot(body: DiscordBotLoginBody, options?: any) {
        return OauthApiFp(this.configuration).loginDiscordBot(body, options)(this.fetch, this.basePath);
    }

    /**
     * Redirects to discord oauth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public oauth2DiscordGet(options?: any) {
        return OauthApiFp(this.configuration).oauth2DiscordGet(options)(this.fetch, this.basePath);
    }

    /**
     * Redirect handler for discord oauth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public oauth2DiscordRedirectGet(options?: any) {
        return OauthApiFp(this.configuration).oauth2DiscordRedirectGet(options)(this.fetch, this.basePath);
    }

    /**
     * Redirects to twitch oauth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public oauth2TwitchGet(options?: any) {
        return OauthApiFp(this.configuration).oauth2TwitchGet(options)(this.fetch, this.basePath);
    }

    /**
     * Redirect handler for twitch oauth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public oauth2TwitchRedirectGet(options?: any) {
        return OauthApiFp(this.configuration).oauth2TwitchRedirectGet(options)(this.fetch, this.basePath);
    }

}

/**
 * ObjectiveApi - fetch parameter creator
 * @export
 */
export const ObjectiveApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new objective
         * @param {ObjectiveCreate} body Objective to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObjective(body: ObjectiveCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createObjective.');
            }
            const localVarPath = `/scoring/objectives`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ObjectiveCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an objective
         * @param {number} id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjective(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteObjective.');
            }
            const localVarPath = `/scoring/objectives/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an objective by id
         * @param {number} id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjective(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getObjective.');
            }
            const localVarPath = `/scoring/objectives/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectiveApi - functional programming interface
 * @export
 */
export const ObjectiveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new objective
         * @param {ObjectiveCreate} body Objective to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObjective(body: ObjectiveCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Objective> {
            const localVarFetchArgs = ObjectiveApiFetchParamCreator(configuration).createObjective(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an objective
         * @param {number} id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjective(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ObjectiveApiFetchParamCreator(configuration).deleteObjective(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets an objective by id
         * @param {number} id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjective(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Objective> {
            const localVarFetchArgs = ObjectiveApiFetchParamCreator(configuration).getObjective(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ObjectiveApi - factory interface
 * @export
 */
export const ObjectiveApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new objective
         * @param {ObjectiveCreate} body Objective to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObjective(body: ObjectiveCreate, options?: any) {
            return ObjectiveApiFp(configuration).createObjective(body, options)(fetch, basePath);
        },
        /**
         * Deletes an objective
         * @param {number} id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjective(id: number, options?: any) {
            return ObjectiveApiFp(configuration).deleteObjective(id, options)(fetch, basePath);
        },
        /**
         * Gets an objective by id
         * @param {number} id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjective(id: number, options?: any) {
            return ObjectiveApiFp(configuration).getObjective(id, options)(fetch, basePath);
        },
    };
};

/**
 * ObjectiveApi - object-oriented interface
 * @export
 * @class ObjectiveApi
 * @extends {BaseAPI}
 */
export class ObjectiveApi extends BaseAPI {
    /**
     * Creates a new objective
     * @param {ObjectiveCreate} body Objective to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectiveApi
     */
    public createObjective(body: ObjectiveCreate, options?: any) {
        return ObjectiveApiFp(this.configuration).createObjective(body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an objective
     * @param {number} id Objective Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectiveApi
     */
    public deleteObjective(id: number, options?: any) {
        return ObjectiveApiFp(this.configuration).deleteObjective(id, options)(this.fetch, this.basePath);
    }

    /**
     * Gets an objective by id
     * @param {number} id Objective Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectiveApi
     */
    public getObjective(id: number, options?: any) {
        return ObjectiveApiFp(this.configuration).getObjective(id, options)(this.fetch, this.basePath);
    }

}

/**
 * ScoresApi - fetch parameter creator
 * @export
 */
export const ScoresApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches the latest scores for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestScoresForEvent(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getLatestScoresForEvent.');
            }
            const localVarPath = `/events/{event_id}/scores/latest`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Websocket for score updates. Once connected, the client will receive score updates in real-time.
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreWebSocket(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling scoreWebSocket.');
            }
            const localVarPath = `/events/{event_id}/scores/ws`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScoresApi - functional programming interface
 * @export
 */
export const ScoresApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches the latest scores for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestScoresForEvent(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreMap> {
            const localVarFetchArgs = ScoresApiFetchParamCreator(configuration).getLatestScoresForEvent(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Websocket for score updates. Once connected, the client will receive score updates in real-time.
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreWebSocket(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreDiff> {
            const localVarFetchArgs = ScoresApiFetchParamCreator(configuration).scoreWebSocket(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ScoresApi - factory interface
 * @export
 */
export const ScoresApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches the latest scores for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestScoresForEvent(event_id: number, options?: any) {
            return ScoresApiFp(configuration).getLatestScoresForEvent(event_id, options)(fetch, basePath);
        },
        /**
         * Websocket for score updates. Once connected, the client will receive score updates in real-time.
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreWebSocket(event_id: number, options?: any) {
            return ScoresApiFp(configuration).scoreWebSocket(event_id, options)(fetch, basePath);
        },
    };
};

/**
 * ScoresApi - object-oriented interface
 * @export
 * @class ScoresApi
 * @extends {BaseAPI}
 */
export class ScoresApi extends BaseAPI {
    /**
     * Fetches the latest scores for the current event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoresApi
     */
    public getLatestScoresForEvent(event_id: number, options?: any) {
        return ScoresApiFp(this.configuration).getLatestScoresForEvent(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Websocket for score updates. Once connected, the client will receive score updates in real-time.
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoresApi
     */
    public scoreWebSocket(event_id: number, options?: any) {
        return ScoresApiFp(this.configuration).scoreWebSocket(event_id, options)(this.fetch, this.basePath);
    }

}

/**
 * ScoringApi - fetch parameter creator
 * @export
 */
export const ScoringApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new scoring category
         * @param {CategoryCreate} body Category to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(body: CategoryCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCategory.');
            }
            const localVarPath = `/scoring/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CategoryCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new scoring preset
         * @param {ScoringPresetCreate} body Preset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScoringPreset(body: ScoringPresetCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createScoringPreset.');
            }
            const localVarPath = `/scoring/presets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScoringPresetCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a scoring category
         * @param {number} id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCategory.');
            }
            const localVarPath = `/scoring/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a scoring preset by id
         * @param {number} id Preset Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScoringPreset(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteScoringPreset.');
            }
            const localVarPath = `/scoring/presets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the rules for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRulesForEvent(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getRulesForEvent.');
            }
            const localVarPath = `/events/{event_id}/rules`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a scoring category by id
         * @param {number} id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringCategory(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getScoringCategory.');
            }
            const localVarPath = `/scoring/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a scoring preset by id
         * @param {number} id Preset Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringPreset(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getScoringPreset.');
            }
            const localVarPath = `/scoring/presets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the scoring presets for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringPresetsForEvent(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getScoringPresetsForEvent.');
            }
            const localVarPath = `/events/{event_id}/scoring-presets`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScoringApi - functional programming interface
 * @export
 */
export const ScoringApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new scoring category
         * @param {CategoryCreate} body Category to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(body: CategoryCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Category> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).createCategory(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new scoring preset
         * @param {ScoringPresetCreate} body Preset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScoringPreset(body: ScoringPresetCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoringPreset> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).createScoringPreset(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a scoring category
         * @param {number} id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).deleteCategory(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a scoring preset by id
         * @param {number} id Preset Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScoringPreset(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).deleteScoringPreset(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches the rules for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRulesForEvent(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Category> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).getRulesForEvent(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a scoring category by id
         * @param {number} id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringCategory(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Category> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).getScoringCategory(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a scoring preset by id
         * @param {number} id Preset Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringPreset(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoringPreset> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).getScoringPreset(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches the scoring presets for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringPresetsForEvent(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ScoringPreset>> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).getScoringPresetsForEvent(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ScoringApi - factory interface
 * @export
 */
export const ScoringApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new scoring category
         * @param {CategoryCreate} body Category to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(body: CategoryCreate, options?: any) {
            return ScoringApiFp(configuration).createCategory(body, options)(fetch, basePath);
        },
        /**
         * Creates a new scoring preset
         * @param {ScoringPresetCreate} body Preset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScoringPreset(body: ScoringPresetCreate, options?: any) {
            return ScoringApiFp(configuration).createScoringPreset(body, options)(fetch, basePath);
        },
        /**
         * Deletes a scoring category
         * @param {number} id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: number, options?: any) {
            return ScoringApiFp(configuration).deleteCategory(id, options)(fetch, basePath);
        },
        /**
         * Deletes a scoring preset by id
         * @param {number} id Preset Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScoringPreset(id: number, options?: any) {
            return ScoringApiFp(configuration).deleteScoringPreset(id, options)(fetch, basePath);
        },
        /**
         * Fetches the rules for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRulesForEvent(event_id: number, options?: any) {
            return ScoringApiFp(configuration).getRulesForEvent(event_id, options)(fetch, basePath);
        },
        /**
         * Fetches a scoring category by id
         * @param {number} id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringCategory(id: number, options?: any) {
            return ScoringApiFp(configuration).getScoringCategory(id, options)(fetch, basePath);
        },
        /**
         * Fetches a scoring preset by id
         * @param {number} id Preset Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringPreset(id: number, options?: any) {
            return ScoringApiFp(configuration).getScoringPreset(id, options)(fetch, basePath);
        },
        /**
         * Fetches the scoring presets for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringPresetsForEvent(event_id: number, options?: any) {
            return ScoringApiFp(configuration).getScoringPresetsForEvent(event_id, options)(fetch, basePath);
        },
    };
};

/**
 * ScoringApi - object-oriented interface
 * @export
 * @class ScoringApi
 * @extends {BaseAPI}
 */
export class ScoringApi extends BaseAPI {
    /**
     * Creates a new scoring category
     * @param {CategoryCreate} body Category to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public createCategory(body: CategoryCreate, options?: any) {
        return ScoringApiFp(this.configuration).createCategory(body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a new scoring preset
     * @param {ScoringPresetCreate} body Preset to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public createScoringPreset(body: ScoringPresetCreate, options?: any) {
        return ScoringApiFp(this.configuration).createScoringPreset(body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a scoring category
     * @param {number} id Category Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public deleteCategory(id: number, options?: any) {
        return ScoringApiFp(this.configuration).deleteCategory(id, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a scoring preset by id
     * @param {number} id Preset Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public deleteScoringPreset(id: number, options?: any) {
        return ScoringApiFp(this.configuration).deleteScoringPreset(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches the rules for the current event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public getRulesForEvent(event_id: number, options?: any) {
        return ScoringApiFp(this.configuration).getRulesForEvent(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a scoring category by id
     * @param {number} id Category Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public getScoringCategory(id: number, options?: any) {
        return ScoringApiFp(this.configuration).getScoringCategory(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a scoring preset by id
     * @param {number} id Preset Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public getScoringPreset(id: number, options?: any) {
        return ScoringApiFp(this.configuration).getScoringPreset(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches the scoring presets for the current event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public getScoringPresetsForEvent(event_id: number, options?: any) {
        return ScoringApiFp(this.configuration).getScoringPresetsForEvent(event_id, options)(this.fetch, this.basePath);
    }

}

/**
 * SignupApi - fetch parameter creator
 * @export
 */
export const SignupApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a signup for the authenticated user
         * @param {number} event_id Event Id
         * @param {SignupCreate} body Signup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignup(event_id: number, body: SignupCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling createSignup.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSignup.');
            }
            const localVarPath = `/events/{event_id}/signups/self`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SignupCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the authenticated user's signup for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSignup(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteSignup.');
            }
            const localVarPath = `/events/{event_id}/signups/self`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all signups for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSignups(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getEventSignups.');
            }
            const localVarPath = `/events/{event_id}/signups`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches an authenticated user's signup for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalSignup(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getPersonalSignup.');
            }
            const localVarPath = `/events/{event_id}/signups/self`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignupApi - functional programming interface
 * @export
 */
export const SignupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a signup for the authenticated user
         * @param {number} event_id Event Id
         * @param {SignupCreate} body Signup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignup(event_id: number, body: SignupCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Signup> {
            const localVarFetchArgs = SignupApiFetchParamCreator(configuration).createSignup(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes the authenticated user's signup for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSignup(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SignupApiFetchParamCreator(configuration).deleteSignup(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all signups for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSignups(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: Array<Signup>; }> {
            const localVarFetchArgs = SignupApiFetchParamCreator(configuration).getEventSignups(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches an authenticated user's signup for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalSignup(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Signup> {
            const localVarFetchArgs = SignupApiFetchParamCreator(configuration).getPersonalSignup(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SignupApi - factory interface
 * @export
 */
export const SignupApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a signup for the authenticated user
         * @param {number} event_id Event Id
         * @param {SignupCreate} body Signup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignup(event_id: number, body: SignupCreate, options?: any) {
            return SignupApiFp(configuration).createSignup(event_id, body, options)(fetch, basePath);
        },
        /**
         * Deletes the authenticated user's signup for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSignup(event_id: number, options?: any) {
            return SignupApiFp(configuration).deleteSignup(event_id, options)(fetch, basePath);
        },
        /**
         * Fetches all signups for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSignups(event_id: number, options?: any) {
            return SignupApiFp(configuration).getEventSignups(event_id, options)(fetch, basePath);
        },
        /**
         * Fetches an authenticated user's signup for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalSignup(event_id: number, options?: any) {
            return SignupApiFp(configuration).getPersonalSignup(event_id, options)(fetch, basePath);
        },
    };
};

/**
 * SignupApi - object-oriented interface
 * @export
 * @class SignupApi
 * @extends {BaseAPI}
 */
export class SignupApi extends BaseAPI {
    /**
     * Creates a signup for the authenticated user
     * @param {number} event_id Event Id
     * @param {SignupCreate} body Signup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignupApi
     */
    public createSignup(event_id: number, body: SignupCreate, options?: any) {
        return SignupApiFp(this.configuration).createSignup(event_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes the authenticated user's signup for the event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignupApi
     */
    public deleteSignup(event_id: number, options?: any) {
        return SignupApiFp(this.configuration).deleteSignup(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all signups for the event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignupApi
     */
    public getEventSignups(event_id: number, options?: any) {
        return SignupApiFp(this.configuration).getEventSignups(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches an authenticated user's signup for the event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignupApi
     */
    public getPersonalSignup(event_id: number, options?: any) {
        return SignupApiFp(this.configuration).getPersonalSignup(event_id, options)(this.fetch, this.basePath);
    }

}

/**
 * StreamsApi - fetch parameter creator
 * @export
 */
export const StreamsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches all twitch streams for the current event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreams(options: any = {}): FetchArgs {
            const localVarPath = `/streams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreamsApi - functional programming interface
 * @export
 */
export const StreamsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches all twitch streams for the current event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreams(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TwitchStream>> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).getStreams(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StreamsApi - factory interface
 * @export
 */
export const StreamsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches all twitch streams for the current event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreams(options?: any) {
            return StreamsApiFp(configuration).getStreams(options)(fetch, basePath);
        },
    };
};

/**
 * StreamsApi - object-oriented interface
 * @export
 * @class StreamsApi
 * @extends {BaseAPI}
 */
export class StreamsApi extends BaseAPI {
    /**
     * Fetches all twitch streams for the current event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getStreams(options?: any) {
        return StreamsApiFp(this.configuration).getStreams(options)(this.fetch, this.basePath);
    }

}

/**
 * SubmissionApi - fetch parameter creator
 * @export
 */
export const SubmissionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a submission
         * @param {number} event_id Event Id
         * @param {number} submission_id Submission Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmission(event_id: number, submission_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteSubmission.');
            }
            // verify required parameter 'submission_id' is not null or undefined
            if (submission_id === null || submission_id === undefined) {
                throw new RequiredError('submission_id','Required parameter submission_id was null or undefined when calling deleteSubmission.');
            }
            const localVarPath = `/events/{event_id}/submissions/{submission_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submission_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all submissions for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissions(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getSubmissions.');
            }
            const localVarPath = `/events/{event_id}/submissions`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reviews a submission
         * @param {number} event_id Event Id
         * @param {number} submission_id Submission Id
         * @param {SubmissionReview} submission Submission review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewSubmission(event_id: number, submission_id: number, submission: SubmissionReview, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling reviewSubmission.');
            }
            // verify required parameter 'submission_id' is not null or undefined
            if (submission_id === null || submission_id === undefined) {
                throw new RequiredError('submission_id','Required parameter submission_id was null or undefined when calling reviewSubmission.');
            }
            // verify required parameter 'submission' is not null or undefined
            if (submission === null || submission === undefined) {
                throw new RequiredError('submission','Required parameter submission was null or undefined when calling reviewSubmission.');
            }
            const localVarPath = `/events/{event_id}/submissions/{submission_id}/review`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submission_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmissionReview" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(submission || {}) : (submission || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a bounty for an event
         * @param {number} event_id Event Id
         * @param {SubmissionCreate} body Submission to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitBounty(event_id: number, body: SubmissionCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling submitBounty.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling submitBounty.');
            }
            const localVarPath = `/events/{event_id}/submissions`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmissionCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmissionApi - functional programming interface
 * @export
 */
export const SubmissionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a submission
         * @param {number} event_id Event Id
         * @param {number} submission_id Submission Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmission(event_id: number, submission_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmissionApiFetchParamCreator(configuration).deleteSubmission(event_id, submission_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all submissions for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissions(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Submission>> {
            const localVarFetchArgs = SubmissionApiFetchParamCreator(configuration).getSubmissions(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Reviews a submission
         * @param {number} event_id Event Id
         * @param {number} submission_id Submission Id
         * @param {SubmissionReview} submission Submission review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewSubmission(event_id: number, submission_id: number, submission: SubmissionReview, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submission> {
            const localVarFetchArgs = SubmissionApiFetchParamCreator(configuration).reviewSubmission(event_id, submission_id, submission, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Submits a bounty for an event
         * @param {number} event_id Event Id
         * @param {SubmissionCreate} body Submission to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitBounty(event_id: number, body: SubmissionCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submission> {
            const localVarFetchArgs = SubmissionApiFetchParamCreator(configuration).submitBounty(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubmissionApi - factory interface
 * @export
 */
export const SubmissionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes a submission
         * @param {number} event_id Event Id
         * @param {number} submission_id Submission Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmission(event_id: number, submission_id: number, options?: any) {
            return SubmissionApiFp(configuration).deleteSubmission(event_id, submission_id, options)(fetch, basePath);
        },
        /**
         * Fetches all submissions for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissions(event_id: number, options?: any) {
            return SubmissionApiFp(configuration).getSubmissions(event_id, options)(fetch, basePath);
        },
        /**
         * Reviews a submission
         * @param {number} event_id Event Id
         * @param {number} submission_id Submission Id
         * @param {SubmissionReview} submission Submission review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewSubmission(event_id: number, submission_id: number, submission: SubmissionReview, options?: any) {
            return SubmissionApiFp(configuration).reviewSubmission(event_id, submission_id, submission, options)(fetch, basePath);
        },
        /**
         * Submits a bounty for an event
         * @param {number} event_id Event Id
         * @param {SubmissionCreate} body Submission to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitBounty(event_id: number, body: SubmissionCreate, options?: any) {
            return SubmissionApiFp(configuration).submitBounty(event_id, body, options)(fetch, basePath);
        },
    };
};

/**
 * SubmissionApi - object-oriented interface
 * @export
 * @class SubmissionApi
 * @extends {BaseAPI}
 */
export class SubmissionApi extends BaseAPI {
    /**
     * Deletes a submission
     * @param {number} event_id Event Id
     * @param {number} submission_id Submission Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public deleteSubmission(event_id: number, submission_id: number, options?: any) {
        return SubmissionApiFp(this.configuration).deleteSubmission(event_id, submission_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all submissions for an event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public getSubmissions(event_id: number, options?: any) {
        return SubmissionApiFp(this.configuration).getSubmissions(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Reviews a submission
     * @param {number} event_id Event Id
     * @param {number} submission_id Submission Id
     * @param {SubmissionReview} submission Submission review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public reviewSubmission(event_id: number, submission_id: number, submission: SubmissionReview, options?: any) {
        return SubmissionApiFp(this.configuration).reviewSubmission(event_id, submission_id, submission, options)(this.fetch, this.basePath);
    }

    /**
     * Submits a bounty for an event
     * @param {number} event_id Event Id
     * @param {SubmissionCreate} body Submission to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public submitBounty(event_id: number, body: SubmissionCreate, options?: any) {
        return SubmissionApiFp(this.configuration).submitBounty(event_id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * TeamApi - fetch parameter creator
 * @export
 */
export const TeamApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds users to teams
         * @param {number} event_id Event Id
         * @param {Array<TeamUserCreate>} body Users to add to teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling addUsersToTeams.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addUsersToTeams.');
            }
            const localVarPath = `/events/{event_id}/teams/users`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;TeamUserCreate&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a team for an event
         * @param {number} event_id Event Id
         * @param {TeamCreate} body Team to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(event_id: number, body: TeamCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling createTeam.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTeam.');
            }
            const localVarPath = `/events/{event_id}/teams`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TeamCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a team
         * @param {number} event_id Event Id
         * @param {number} team_id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(event_id: number, team_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteTeam.');
            }
            // verify required parameter 'team_id' is not null or undefined
            if (team_id === null || team_id === undefined) {
                throw new RequiredError('team_id','Required parameter team_id was null or undefined when calling deleteTeam.');
            }
            const localVarPath = `/events/{event_id}/teams/{team_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(team_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a team by id
         * @param {number} event_id Event Id
         * @param {number} team_id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(event_id: number, team_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getTeam.');
            }
            // verify required parameter 'team_id' is not null or undefined
            if (team_id === null || team_id === undefined) {
                throw new RequiredError('team_id','Required parameter team_id was null or undefined when calling getTeam.');
            }
            const localVarPath = `/events/{event_id}/teams/{team_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(team_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all teams for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getTeams.');
            }
            const localVarPath = `/events/{event_id}/teams`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamApi - functional programming interface
 * @export
 */
export const TeamApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds users to teams
         * @param {number} event_id Event Id
         * @param {Array<TeamUserCreate>} body Users to add to teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).addUsersToTeams(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a team for an event
         * @param {number} event_id Event Id
         * @param {TeamCreate} body Team to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(event_id: number, body: TeamCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).createTeam(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a team
         * @param {number} event_id Event Id
         * @param {number} team_id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(event_id: number, team_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).deleteTeam(event_id, team_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a team by id
         * @param {number} event_id Event Id
         * @param {number} team_id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(event_id: number, team_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeam(event_id, team_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all teams for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeams(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamApi - factory interface
 * @export
 */
export const TeamApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds users to teams
         * @param {number} event_id Event Id
         * @param {Array<TeamUserCreate>} body Users to add to teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options?: any) {
            return TeamApiFp(configuration).addUsersToTeams(event_id, body, options)(fetch, basePath);
        },
        /**
         * Creates a team for an event
         * @param {number} event_id Event Id
         * @param {TeamCreate} body Team to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(event_id: number, body: TeamCreate, options?: any) {
            return TeamApiFp(configuration).createTeam(event_id, body, options)(fetch, basePath);
        },
        /**
         * Deletes a team
         * @param {number} event_id Event Id
         * @param {number} team_id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(event_id: number, team_id: number, options?: any) {
            return TeamApiFp(configuration).deleteTeam(event_id, team_id, options)(fetch, basePath);
        },
        /**
         * Fetches a team by id
         * @param {number} event_id Event Id
         * @param {number} team_id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(event_id: number, team_id: number, options?: any) {
            return TeamApiFp(configuration).getTeam(event_id, team_id, options)(fetch, basePath);
        },
        /**
         * Fetches all teams for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(event_id: number, options?: any) {
            return TeamApiFp(configuration).getTeams(event_id, options)(fetch, basePath);
        },
    };
};

/**
 * TeamApi - object-oriented interface
 * @export
 * @class TeamApi
 * @extends {BaseAPI}
 */
export class TeamApi extends BaseAPI {
    /**
     * Adds users to teams
     * @param {number} event_id Event Id
     * @param {Array<TeamUserCreate>} body Users to add to teams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options?: any) {
        return TeamApiFp(this.configuration).addUsersToTeams(event_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a team for an event
     * @param {number} event_id Event Id
     * @param {TeamCreate} body Team to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public createTeam(event_id: number, body: TeamCreate, options?: any) {
        return TeamApiFp(this.configuration).createTeam(event_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a team
     * @param {number} event_id Event Id
     * @param {number} team_id Team Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public deleteTeam(event_id: number, team_id: number, options?: any) {
        return TeamApiFp(this.configuration).deleteTeam(event_id, team_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a team by id
     * @param {number} event_id Event Id
     * @param {number} team_id Team Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeam(event_id: number, team_id: number, options?: any) {
        return TeamApiFp(this.configuration).getTeam(event_id, team_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all teams for an event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeams(event_id: number, options?: any) {
        return TeamApiFp(this.configuration).getTeams(event_id, options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds users to teams
         * @param {number} event_id Event Id
         * @param {Array<TeamUserCreate>} body Users to add to teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling addUsersToTeams.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addUsersToTeams.');
            }
            const localVarPath = `/events/{event_id}/teams/users`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;TeamUserCreate&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the permissions of a user
         * @param {number} userId User Id
         * @param {Array<Permission>} permissions Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePermissions(userId: number, permissions: Array<Permission>, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling changePermissions.');
            }
            // verify required parameter 'permissions' is not null or undefined
            if (permissions === null || permissions === undefined) {
                throw new RequiredError('permissions','Required parameter permissions was null or undefined when calling changePermissions.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Permission&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(permissions || {}) : (permissions || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options: any = {}): FetchArgs {
            const localVarPath = `/users/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all users for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForEvent(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getUsersForEvent.');
            }
            const localVarPath = `/events/{event_id}/users`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs out the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options: any = {}): FetchArgs {
            const localVarPath = `/users/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an authentication provider from the authenticated user
         * @param {string} provider Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAuth(provider: string, options: any = {}): FetchArgs {
            // verify required parameter 'provider' is not null or undefined
            if (provider === null || provider === undefined) {
                throw new RequiredError('provider','Required parameter provider was null or undefined when calling removeAuth.');
            }
            const localVarPath = `/users/remove-auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the authenticated users display name
         * @param {UserUpdate} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: UserUpdate, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateUser.');
            }
            const localVarPath = `/users/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds users to teams
         * @param {number} event_id Event Id
         * @param {Array<TeamUserCreate>} body Users to add to teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).addUsersToTeams(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Changes the permissions of a user
         * @param {number} userId User Id
         * @param {Array<Permission>} permissions Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePermissions(userId: number, permissions: Array<Permission>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).changePermissions(userId, permissions, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getAllUsers(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all users for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForEvent(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: Array<MinimalUser>; }> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUsersForEvent(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Logs out the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).logout(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes an authentication provider from the authenticated user
         * @param {string} provider Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAuth(provider: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).removeAuth(provider, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the authenticated users display name
         * @param {UserUpdate} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: UserUpdate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateUser(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds users to teams
         * @param {number} event_id Event Id
         * @param {Array<TeamUserCreate>} body Users to add to teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options?: any) {
            return UserApiFp(configuration).addUsersToTeams(event_id, body, options)(fetch, basePath);
        },
        /**
         * Changes the permissions of a user
         * @param {number} userId User Id
         * @param {Array<Permission>} permissions Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePermissions(userId: number, permissions: Array<Permission>, options?: any) {
            return UserApiFp(configuration).changePermissions(userId, permissions, options)(fetch, basePath);
        },
        /**
         * Fetches all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: any) {
            return UserApiFp(configuration).getAllUsers(options)(fetch, basePath);
        },
        /**
         * Fetches the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any) {
            return UserApiFp(configuration).getUser(options)(fetch, basePath);
        },
        /**
         * Fetches all users for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForEvent(event_id: number, options?: any) {
            return UserApiFp(configuration).getUsersForEvent(event_id, options)(fetch, basePath);
        },
        /**
         * Logs out the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any) {
            return UserApiFp(configuration).logout(options)(fetch, basePath);
        },
        /**
         * Removes an authentication provider from the authenticated user
         * @param {string} provider Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAuth(provider: string, options?: any) {
            return UserApiFp(configuration).removeAuth(provider, options)(fetch, basePath);
        },
        /**
         * Updates the authenticated users display name
         * @param {UserUpdate} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: UserUpdate, options?: any) {
            return UserApiFp(configuration).updateUser(user, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Adds users to teams
     * @param {number} event_id Event Id
     * @param {Array<TeamUserCreate>} body Users to add to teams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options?: any) {
        return UserApiFp(this.configuration).addUsersToTeams(event_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Changes the permissions of a user
     * @param {number} userId User Id
     * @param {Array<Permission>} permissions Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public changePermissions(userId: number, permissions: Array<Permission>, options?: any) {
        return UserApiFp(this.configuration).changePermissions(userId, permissions, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAllUsers(options?: any) {
        return UserApiFp(this.configuration).getAllUsers(options)(this.fetch, this.basePath);
    }

    /**
     * Fetches the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: any) {
        return UserApiFp(this.configuration).getUser(options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all users for an event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsersForEvent(event_id: number, options?: any) {
        return UserApiFp(this.configuration).getUsersForEvent(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Logs out the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public logout(options?: any) {
        return UserApiFp(this.configuration).logout(options)(this.fetch, this.basePath);
    }

    /**
     * Removes an authentication provider from the authenticated user
     * @param {string} provider Provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public removeAuth(provider: string, options?: any) {
        return UserApiFp(this.configuration).removeAuth(provider, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the authenticated users display name
     * @param {UserUpdate} user User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(user: UserUpdate, options?: any) {
        return UserApiFp(this.configuration).updateUser(user, options)(this.fetch, this.basePath);
    }

}

